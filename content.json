{"posts":[{"title":"简历","text":"男 1998 汉族 教育经历 上海交通大学 控制科学与工程 硕士 2020 年 09 月 - 2023 年 03 月 研究方向：机器视觉，视觉测量，激光 SLAM，2D-3D 数据融合 复旦大学 电子信息科学与技术 本科 2016 年 09 月 - 2020 年 06 月 研究方向：无人机路径规划与飞行控制，嵌入式 研究经历 上海交大 - 龙马环卫城市低速无人驾驶环卫车联合开发 2022 年 03 月 - 2022 年 08 月 负责基于 autoware 的无人驾驶定位模块与感知模块算法开发 激光雷达数据采集与扫描匹配，构建 3D 点云地图，绘制矢量地图 实现激光雷达实车定位，融合 GNSS 卫星定位进行定位初始化 完成图像和点云数据融合，生成 RGB 点云 基于 darknet 框架进行 YOLOv3 模型训练与部署，对图像进行目标检测，并与点云聚类结果进行融合过滤 自动化产线物料分拣 2021 年 07 月 - 2022 年 01 月 目标检测与位姿估计 基于自研三维扫描仪对自动化流水线上目标进行扫描，对图像进行分类与分割，重建出 ROI 区域三维点云 将目标点云与 CAD 数模进行配准得到目标物料的 6D 位姿 物料分拣 基于 WinSock2 实现上位机与机械臂控制器的数据通信与指令收发 基于机械臂坐标系与扫描仪坐标系下三维点集的刚体变换，完成手眼标定 将扫描仪获得的目标物料的类别与位姿发送给机械臂控制器，结合下位机程序完成目标自动分拣 结构光三维扫描仪研发 2020 年 10 月 - 2021 年 06 月 搭建三维扫描仪硬件系统 使用单个工业相机，分别搭配普通家用软触发投影仪和硬触发光机投影仪，搭建两套三维扫描仪硬件系统，完成安装调试 结构光三维重建算法开发 借助 YOLOv3 进行非对称圆点标定板检测，进行单目相机标定 实现相移码编解码算法，控制投影仪向目标区域投射相移码结构光，触发相机拍照并进行解码 完成相机和投影仪的立体标定，实现对目标区域的三维重建 基于 Qt 搭建三维扫描仪 GUI 界面，实现相机与投影仪的联调联控，对扫描得到的点云进行可视化 复旦大学曦源项目无人机路径规划 2018 年 06 月 - 2019 年 06 月 基于 Pixhawk 开源飞控搭建无人机系统，机载树莓派作为控制中心，在已知场景中用 RRT 算法进行路径规划，并使用双向 RRT 来加快搜索速度，控制无人机沿规划路径飞往指定地点 实习经历 RoboWay - 嵌入式开发 2019 年 04 月 - 2019 年 07 月 无人配送机器人电池健康监测模块开发 基于 STM32 工控板使用 RS485 总线协议获取电池模块的电压、充放电电流、温度等信息，进行 HMI 串口屏界面设计并显示电池健康状态信息 论文成果 Siyou Luo &amp; Jun-Guo Lu (2021). Robust stability and stabilization of fractional-order systems with polytopic uncertainties via homogeneous polynomial parameter-dependent matrix forms. International Journal of General Systems, 50:8, 891-914, DOI: 10.1080/03081079.2021.1976774 Siyou Luo, Jun-Guo Lu &amp; Xu-Yi Qiu (2022). Robust normalization and stabilization of descriptor fractional-order systems with uncertainties in all matrices. Journal of the Franklin Institute, 359, 1113-1129, DOI: 10.1016/j.jfranklin.2021.12.016 Siyou Luo &amp; Jun-Guo Lu (2022). Robust normalization and stabilization of descriptor fractional-order systems with polytopic uncertainties in all matrices. Asian Journal of Control. (Under Review) Ming Wei, Jun-guo Lu ,Siyou Luo, et al. Straight line detection algorithm of truck point cloud based on statistical line chart[C]. 2022 Chinese Control And Decision Conference (CCDC). 荣誉奖项 复旦大学优秀学生，信息学院十佳学生、优秀团员 2018-2019 复旦大学毕业生奖学金、优秀毕业生 2019-2020 本科连续四年获国家励志奖学金、校级优秀学生奖学金三等奖 2016-2020 信息学院运动会男子立定跳远金牌 2017.10 TI 杯全国大学生电子设计竞赛上海赛区二等奖 2019.11 第七届“互联网 +”大学生创新创业大赛上海赛区铜奖 2021.10 技能 专业技能 掌握计算机视觉的基本原理、相机成像模型，熟悉双目立体视觉重建的原理与实现 熟练掌握 C/C++，熟悉 Python 语言，能够熟练运用 QT 进行界面设计。熟悉 OpenCV3(计算机视觉库)、PCL（点云库）、Eigen (C++ 线性代数库)、openMVG (多视图几何库) 、WinSock2 （socket 网络接口）等 能够基于 CMake 进行大型软件工程构建，基于 Git Flow 进行团队项目协作 熟练掌握 ROS 系统上功能包的开发与调试，熟悉自动驾驶 Autoware 框架，能对各模块进行调试与二次开发，熟悉激光 SLAM 算法框架 cartographer 掌握嵌入式软硬件开发，熟悉 STM32 单片机，各种总线协议，以及基本外设的使用，能够使用 Altium Designer 软件进行 PCB 设计 语言技能 英语（CET-6） 547 其他证书 机动车驾驶证","link":"/about/"},{"title":"Windows 局域网文件传输","text":"WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端，同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。WinSCP 既可以管理远程 VPS 主机，也可以管理路由器，网络机顶盒等，只要远程设备能 ssh 连接即可。官网：https://winscp.net/eng/docs/lang:chs 被远程的 PC 下载 OpenSSH-Win64.zip，并解压到本地； 在 C:\\Program Files 文件夹中新建 OpenSSH 文件夹，并将（1）中解压的所有文件 copy 到 OpenSSH 文件夹中，此处都需要 Administrator 的权限 ；注：实际上这里 OpenSSH 的解压目录可以不放在 C 盘，就无需管理员权限 管理员权限运行 cmd，切换到： cd C:\\ProgramFiles\\OpenSSH 这个文件夹 , 然后 运行以下命令：powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 添加规则：控制面板 -&gt; 系统和安全 -&gt;Windows 防火墙 -&gt; 高级设置 -&gt; 入栈规则 -&gt;”新建规则”：选择“端口 (O)”-&gt; “TCP”, 特定本地端口设置为 22 -&gt; “允许连接”-&gt; 默认全选，下一步 -&gt; 名称： sshd ，完成。 注：新建规则的名称一定要是 sshd 启动 OpenSSH 相关服务：“此电脑”上右击，选择“管理”，在“服务和应用程序”中选择“服务”，在右侧的所有服务中找到“OpenSSH Authentication Agent”和“OpenSSH SSH Server”，右击并在“属性”中将启动类型修改为“自动”，点击确定。注：除了将启动类型修改为自动之外，还需要启动一下这两个服务，否则就要重启电脑，让这两个服务开机自启动 本地 PC 安装 WinSCP: https://winscp.net/eng/download.php 打开 WinSCP:文件协议：SFTP主机名：就是被远程那台 PC 的 IP端口号：22用户名和密码：就是被远程那台 PC 的用户名和密码 点击“登录”。 注意事项 以上设置的两台 PC 是在同一网络内，比如校园网 (校园 VPN 可以轻松实现)。 参考： https://blog.csdn.net/qccz123456/article/details/80345999 关于“文件’’…\\putty.exe’没有找到”的错误解决方法： 下载： putty.exe ，并放到 WinSCP 安装位置中的 PuTTY 文件夹下 打开 WinSCP，选择“选项”-&gt;“选项”-&gt; 集成 -&gt; 应用程序，修改 PuTTY/Terminal 客户端路径为 putty.exe 所在的路径 -&gt; 确定。 参考 本文主要转载自: win10 使用 WinSCP 远程另一台 Win10 - 博客园 WinSCP 使用教程 - CSDN","link":"/blogs/winscp/"},{"title":"书签","text":"Linux 命令大全搜索工具，内容包含 Linux 命令手册、详解、学习、搜集。 Gitee 极速下载 现代 C++ 教程：高速上手 C++ 11/14/17/20 CMake 菜谱（CMake Cookbook 中文版） cpp 中文参考手册 | Github C++ 中文参考手册 https://cplusplus.com/ C++ 学习 chengxumiaodaren/cpp-learning | Github 521xueweihan/HelloGitHub - 分享 GitHub 上有趣、入门级的开源项目 开源中国 OSCHINA Microsoft’s C++ Standard Library | Github Microsoft 技术文档 Microsoft C++、C 和汇编程序文档 在线编程 C++ shell 在线编程 Coliru 图说设计模式","link":"/blogs/mark/"},{"title":"编译 VTK","text":"可视化工具包 (VTK) 是一种用于操作和显示科学数据的开源软件。它配备了最先进的 3D 渲染工具，一套用于 3D 交互的小部件，以及广泛的 2D 绘图功能。VTK 是 Kitware 软件开发 支持 平台集合的一部分。该平台在全球范围内用于商业应用和研发。例如，请参阅 VTK in Action。– https://www.vtk.org/about VTK 官网 VTK 官方文档 VTK 官方 WiKi VTK 下载 VTK 配置与编译 这里以 VTK 9.1.0 为例 Prerequisites参考 VTK Documentation &gt;&gt; build.md#prerequisites CMake &gt;= 3.12 (越新越好) Qt &gt;= 5.9 下载 下载完整仓库(不推荐)12345&gt; git clone --recursive https://gitlab.kitware.com/vtk/vtk.git&gt; cd .\\vtk\\&gt; git checkout v9.1.0 &gt; cd ThirdParty\\vtkm\\vtkvtkm\\vtk-m&gt; git checkout 4df064f37 精简下载1&gt; git clone --recursive --branch v9.1.0 --depth=1 https://gitlab.kitware.com/vtk/vtk.git 配置与编译 VTK 编译 Qt+PCL+VS 实现点云 Gui 界面显示 (private) 运行 CMake-GUI 并将源码目录设置为 clone 下来的 vtk 仓库目录, 并自行指定 build 目录. 使用 Add Entry 按钮添加缓存变量 CMAKE_DEBUG_POSTFIX，类型为 STRING，值设置为 -gd。这是为了将最后编译的 debug 文件与 release 文件区分开来。 点击 Configure, 选择安装的 Visual Studio 的版本，选择 x64 平台，选择平台工具集 v141(对应 VS2017 默认的平台工具集)，点击 Finish 开始配置。 修改 CMAKE_INSTALL_PREFIX 变量，指定安装目录。 可以选择需要构建的内容，这里 只勾选 BUILD_SHARED_LIBS，不对文档、示例和测试进行生成，这样可以节省生成和构建的时间。 BUILD_DOCUMENTATION, BUILD_EXAMPLES, BUILD_SHARED_LIBS, BUILD_TESTING。 使用 CMake-GUI 中的搜索框，输入 Qt，将自动过滤出与 Qt 相关的配置项：将 VTK_GROUP_ENABLE_Qt, VTK_MODULE_ENABLE_VTK_GUISupportQtSQL VTK_MODULE_ENABLE_VTK_GUISupportQt VTK_MODULE_ENABLE_VTK_GUISupportQtQuick VTK_MODULE_ENABLE_VTK_RenderingQt VTK_MODULE_ENABLE_VTK_ViewsQt设置为 WANT; VTK_QT_VERSION 设置为 5。注意，不同版本 VTK 在这里显示出来的选项可能不同，如果看到了 VTK_Group_Qt, 将其勾选即可。 再次点击 Configure, 然后通过搜索框过滤 Qt, 检查相关项的 _DIR 是否检测成功, 否则需手动指定。完成后点击 Configure, 然后点击 Generate 生成 VS 解决方案。点击 Open Project, 将自动通过 VS 打开。 点击 CMake-GUI &gt;&gt; Tools &gt;&gt; Show My Changes 可以看到自己所做的修改如下 My Changes12345678910111213Commandline options:-DVTK_GROUP_ENABLE_Qt:STRING=&quot;WANT&quot; -DVTK_MODULE_ENABLE_VTK_GUISupportQtSQL:STRING=&quot;WANT&quot; -DVTK_MODULE_ENABLE_VTK_GUISupportQt:STRING=&quot;WANT&quot; -DVTK_MODULE_ENABLE_VTK_GUISupportQtQuick:STRING=&quot;WANT&quot; -DVTK_MODULE_ENABLE_VTK_RenderingQt:STRING=&quot;WANT&quot; -DVTK_MODULE_ENABLE_VTK_ViewsQt:STRING=&quot;WANT&quot; -DVTK_QT_VERSION:STRING=&quot;5&quot; Cache file:VTK_GROUP_ENABLE_Qt:STRING=WANTVTK_MODULE_ENABLE_VTK_GUISupportQtSQL:STRING=WANTVTK_MODULE_ENABLE_VTK_GUISupportQt:STRING=WANTVTK_MODULE_ENABLE_VTK_GUISupportQtQuick:STRING=WANTVTK_MODULE_ENABLE_VTK_RenderingQt:STRING=WANTVTK_MODULE_ENABLE_VTK_ViewsQt:STRING=WANTVTK_QT_VERSION:STRING=5 在 VS 中点击 生成 &gt;&gt; 批生成: 勾选如下选项后点击 生成 , 等待 VS 自动完成生成与安装。 ALL_BUILD,Debug,x64 ALL_BUILD,Release,x64 INSTALL,Debug,x64 INSTALL,Release,x64 在安装目录可以看到如下库文件结构 show-tree -depth 212345678910D:\\ProgramFiles\\VTK\\VTK9.1.0├──bin├──include│ └──vtk-9.1├──lib│ ├──cmake│ ├──qml│ └──vtk└──share └──licenses 作为第三方库使用 在 CMakeLists.txt 中加入如下内容, 并且在 Configure 时可能需要指定安装目录-DVTK_DIR:PATH=&quot;D:/ProgramFiles/VTK/VTK9.1.0/lib/cmake/vtk-9.1&quot; CMakeLists.txt12345678910111213141516...find_package(VTK REQUIRED) add_executable(${PROJECT_NAME} ...) target_link_libraries(${PROJECT_NAME} ${VTK_LIBRARIES} ) vtk_module_autoinit( TARGETS ${PROJECT_NAME} MODULES ${VTK_LIBRARIES}) 程序运行时需确保 vtk 相关 dll 能够被找到。 参考 VTK9.1.0 在 Windows10+VS2019+Qt 5.15.2 环境下编译安装以及 VTK 应用于 QT VTK9.1.0 + VS2022 + Qt5.12 编译 Qt6.0.1 + vtk9.1.0 + Cmake 编译运行","link":"/blogs/build_vtk/"},{"title":"搭建博客","text":"基于 Hexo 搭建静态博客网站，使用 ICARUS 主题，并部署在 Github Pages 上。 在 Github 创建网站 参考 GitHub Pages 快速入门 在 Github 创建一个带有自己用户名的仓库 username.github.io, 例如 siyouluo.github.io.然后在该仓库下新建一个 index.html 文件 index.html1hello world 稍等片刻, 即可访问 https://siyouluo.github.io 打开网站。 具体的网址可以在仓库的 Settings -&gt; Pages -&gt; GitHub Pages 页面看到: Your site is live at &lt;some url&gt;. 自定义域名 (可选)GitHub Pages 提供的域名是用户名后跟着 .github.io, 如果自己有域名, 可以使用自己的域名来访问该网站. 登录自己的域名管理页面 (例如腾讯云域名解析 https://console.dnspod.cn/dns/), 添加两条记录, 其中 @ 主机的记录值是通过 ping siyouluo.github.io 显示出来的 ip 地址. 主机记录 记录类型 记录值 @ A 185.199.111.153 www CNAME siyouluo.github.io 补充 实际上, 通过 ping 得到的 ip 地址总是在如下四个地址之间变动, 在进行域名解析时可以添加四条 A 记录, 分别指向四个 ip.实测中, 至少需要有一条 A 记录指向如下之一的 ip 地址即可. ping siyouluo.github.io1234185.199.108.153185.199.109.153185.199.110.153185.199.111.153 参考 Managing a custom domain for your GitHub Pages site 在 Github 仓库 Settings -&gt; Pages -&gt; GitHub Pages: Custom domain 填入自己的域名 (例如 luosiyou.cn), 并等待域名解析完成后, 勾选 [√] Enforce HTTPS, 等待片刻后, 该页面上方将更新网站的地址: Your site is live at https://luosiyou.cn/. 此时将发现 Github 仓库下多了一个 CNAME 文件, 事实上我们也可以在仓库中手动添加这个文件来启用自定义域名 CNAME1luosiyou.cn 使用 Hexo 搭建网站 参考 Hexo 文档 安装 Git 访问 https://nodejs.org/en/download/ 下载 node.js, 双击 node-v16.18.0-x64.msi 文件安装, 默认下一步, 并勾选 [√] Automatically install the necessary tools.; 启动终端运行如下指令, 查看安装是否成功 12&gt; node -v&gt; npm -v 运行示例 >folded12345678910111213141516171819202122PS C:\\Users\\siyou&gt; hexo -vhexo-cli: 4.3.0os: win32 10.0.22000node: 16.18.0v8: 9.4.146.26-node.22uv: 1.43.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.47.0napi: 8llhttp: 6.0.10openssl: 1.1.1q+quiccldr: 41.0icu: 71.1tz: 2022bunicode: 14.0ngtcp2: 0.8.1nghttp3: 0.7.0PS C:\\Users\\siyou&gt; npm -v8.19.2 注意 在 Windows Terminal 内可以使用 cmd 或 PowerShell 运行 而在 PowerShell 中执行时, 可能会报错 无法加载文件，因为在此系统中禁止执行脚本，此时以管理员身份打开 PowerShell 并修改执行策略即可 Windows PowerShell1&gt; Set-ExecutionPolicy RemoteSigned 安装 Hexo 12&gt; npm install -g hexo-cli&gt; npm install hexo-deployer-git --save # 用于网站部署 建站 执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123&gt; hexo init &lt;folder&gt;&gt; cd &lt;folder&gt;&gt; npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 各文件及文件夹用途可以参考 Hexo 建站 示例 12345678910111213PS D:\\Data&gt; hexo init hexo-icarus-pagesINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesINFO Start blogging with Hexo!PS D:\\Data&gt; cd .\\hexo-icarus-pages\\PS D:\\Data\\hexo-icarus-pages&gt; npm installup to date, audited 240 packages in 1s22 packages are looking for funding run `npm fund` for detailsfound 0 vulnerabilities 自定义域名 (可选)如果前面配置了自己的域名, 那么在下一步部署之前, 先在 source/ 文件夹下添加 CNAME 文件,否则部署上去之后, Github 仓库内本来存在的该文件会被删去, 导致域名解析失效. CNAME1luosiyou.cn 修改配置文件 编辑 _config.yml 配置文件 _config.yml123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/siyouluo/siyouluo.github.io.git branch: master 个性化配置 修改 _config.yml 配置文件中的 title, author, url, permalink 等配置项 具体各配置项含义参考 https://hexo.io/zh-cn/docs/configuration 生成博客并部署到 Github Pages 123456789&gt; hexo clean # 清除上一次生成的静态网站文件, 可简写为 hexo c&gt; hexo generate # 生成静态网站, 可简写为 hexo g # 参考 https://hexo.io/zh-cn/docs/generating&gt; hexo server # 在本地启动 hexo 服务, 可通过 http://localhost:4000 预览网站, # 并且修改源文件后刷新浏览器会自动更新页面 # 可简写为 hexo s # 参考 https://hexo.io/zh-cn/docs/server&gt; hexo deploy # 将 public/ 文件夹下的静态网站部署到 Github, 可简写为 hexo d # 参考 https://hexo.io/zh-cn/docs/one-command-deployment 创建新的博客文章 初始化站点时, 存在一个默认的 source/_posts/hello-world.md 文件可以生成第一条博客, 后续如果需要创建新的博客, 使用如下命令. 1&gt; hexo new &quot;My New Post&quot; # 参考 https://hexo.io/zh-cn/docs/writing 在主页中仅显示文章的一部分. 参考 Hexo 文档 &gt;&gt; 标签插件 &gt;&gt; 文章摘要和截断 创建草稿与发布 12&gt; hexo new draft &lt;title&gt; # 创建一个草稿&gt; hexo publish draft &lt;title&gt; # 将草稿发布到 post 使用 ICARUS 主题 安装 icarus 主题12&gt; npm install -S hexo-renderer-inferno&gt; git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 使用 hexo 命令修改主题为 Icarus1&gt; hexo config theme icarus 生成站点123&gt; hexo c&gt; hexo g&gt; hexo s 个性化配置 修改 _config.icarus.yml 文件, 例如更改其中某些链接, 注释掉一些不需要的组件 更换图片: themes/icarus/source/img/ 图标: http://www.fontawesome.com.cn/faicons/ 目录粘性定位: Icarus 主题自定义 &gt;&gt; 目录粘性定位 添加 latex 支持: 在_config.icarus.yml 文件中设置 mathjax: true 参考链接 Hexo 官方文档 Hexo Github 仓库 Icarus 快速上手 Hexo 插入代码块 改图鸭 照片变漫画","link":"/blogs/hexo/"},{"title":"CMake 学习笔记","text":"为了写出更加专业规范的工程项目，有必要学习一下 CMake 工具。这里主要参考Modern CMake, 一般指 CMake 3.4+ ，甚至是 CMake 3.21+. 本项目主要基于 Windows 平台进行讲解，并通过 VS 2017 来进行编译. 相关代码托管在 Github: https://github.com/siyouluo/learn_cmake 环境: Windows 10 Visual Studio Community 2017 CMake 3.18.5 安装 Install cmake - Download binary 预定义变量 含义 CMAKE_MAJOR_VERSION cmake 主版本号 CMAKE_MINOR_VERSION cmake 次版本号 CMAKE_C_FLAGS 设置 C 编译选项 CMAKE_CXX_FLAGS 设置 C++ 编译选项 PROJECT_SOURCE_DIR 工程的根目录 PROJECT_BINARY_DIR 运行 cmake 命令的目录 CMAKE_CURRENT_SOURCE_DIR 当前 CMakeLists.txt 所在路径 CMAKE_CURRENT_BINARY_DIR 目标文件编译目录 EXECUTABLE_OUTPUT_PATH 重新定义目标二进制可执行文件的存放位置 LIBRARY_OUTPUT_PATH 重新定义目标链接库文件的存放位置 CMAKE_ROOT cmake 安装目录 我的示例 通用编译流程 Configure &amp; Generate 123&gt; mkdir build&gt; cd build&gt; cmake .. 在 build 目录下找到 ${PROJECT_NAME}.sln，双击打开，点击 生成解决方案 进入生成的 *.exe 文件目录下，执行 12&gt; .\\demo.exe 2 32 ^ 3 is 8 如果要删除编译生成的 build 文件夹，可在 powershell 执行: Remove-Item -Path build -Recurse Demo1 - 基本框架 本项目仅包含一个 main.cpp 和一个 CMakeLists.txt. 其中 main.cpp 的功能是读入两个浮点数 a,b，计算a^b 并在终端输出.本项目中演示 CMakeLists.txt 的最基础版本，如下. 1234567891011121314# cmake 语法关键字 -- 大 / 小写无关，一般用小写的 cmake_minimum_required# cmake 的最低版本号，注意 VERSION 需要大写cmake_minimum_required(VERSION 3.18)# 设置一个工程名字project(Demo1 VERSION 0.1.0 # 语义化版本 https://semver.org/lang/zh-CN/ DESCRIPTION &quot;demo project&quot; # CMake&gt;=3.9 才可以使用 DESCRIPTION LANGUAGES CXX)# 目标可执行程序 demo， 需要编译 main.cppadd_executable(demo main.cpp) Demo2 - 多文件编译 本项目包含三个代码文件 main.cpp my_power.cpp my_power.h 和一个 CMakeLists.txt. 相比于 Demo1，这里需要修改的只有add_executable 中添加源文件的方式，共有如下几种，选择任意一种即可. 手动列出所有文件 只需在编译目标后面列出所需的全部源文件和头文件即可. 1add_executable(demo main.cpp my_power.cpp my_power.h) 请注意，这里添加头文件不是必须的，但是在用 cmake 配合 IDE 使用 (例如通过 cmake 配置并生成 visual studio 解决方案) 时，添加头文件列表可以显式地把自己的头文件放到一个 Header Files 分组内，如下是 VS 的 解决方案资源管理器 中显示的样子。如果 add_executable 没有添加头文件，那么用户自己的头文件 my_power.h 就会被放在 外部依赖项 里面。 12345678910111213141516解决方案 'Demo2'(3 个项目)- ALL_BUILD- demo - 引用 - 外部依赖项 - iostream - stdio.h - stdlib.h ... - Header Files - my_power.h - Source Files - main.cpp - my_power.cpp - CMakeLists.txt- ZERO_CHECK 自动列出目录下所有源文件 使用 aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 将指定路径下的’cpp/cc/c’源文件全部绑定到 SRC_LIST，然后在添加目标时使用该变量. 123aux_source_directory(. SRC_LIST)message(STATUS &quot;SRC_LIST=${SRC_LIST}&quot;) # 在配置的时候打印输出变量 SRC_LISTadd_executable(demo ${SRC_LIST}) 注意这样不会添加头文件, 配置时终端输出如下, 其中 SRC_LIST 只有源文件，没有头文件. 12345build&gt; cmake ..-- Selecting Windows SDK version 10.0.17763.0 to target Windows 10.0.19044.-- SRC_LIST=./main.cpp;./my_power.cpp-- Configuring done-- Generating done 使用通配符设置文件列表 通过 file(GLOB VAR &quot;*.cpp&quot;) 来将所有 cpp 文件放到变量 VAR 中，然后在添加目标时使用该变量. 12345678file(GLOB ALL_SOURCES &quot;*.cpp&quot;) # 查找指定目录下的所有.cpp, 并存放到指定变量名 ALL_SOURCES 中file(GLOB ALL_INCLUDES &quot;*.h&quot;) # 查找指定目录下的所有.cpp, 并存放到指定变量名 ALL_INCLUDES 中# 将变量 ALL_SRCS 设置为 ALL_SOURCES + ALL_INCLUDESset(ALL_SRCS ${ALL_SOURCES} ${ALL_INCLUDES})add_executable(demo ${ALL_SRCS}) 在一条 file() 语句中可以添加多个匹配项，中间用空格隔开即可, 如: file(GLOB VAR &quot;*.cpp&quot; &quot;*.cc&quot; &quot;*.h&quot; &quot;./FOLDER/*.cpp&quot;) 匹配方法： file(GLOB SRC_LIST &quot;*.cpp&quot;)只匹配当前路径下的所有 cpp 文件 file(GLOB_RECURSE SRC_LIST &quot;*.cpp&quot;)递归搜索所有路径下的所有 cpp 文件 file(GLOB SRC_COMMON_LIST RELATIVE &quot;common&quot; &quot;*.cpp&quot;)在 common 目录下搜索 cpp 文件 在 Modern CMake 行为准则 中提到应该避免使用这种方法，因为在执行 cmake .. 之后如果新添加了源文件，该文件不会被编译系统感知到，也就不会被编译，除非重新再执行一次cmake ..(虽然我觉得这不是件什么大不了的事). 文件模块化管理 一个良好的工程项目必然包含多个不同功能模块，同样在 cmake 中也可以将其按照功能的不同进行分组管理。 123456789file(GLOB MY_POWER_FILES &quot;my_power.cpp&quot; &quot;my_power.h&quot;) # 将 my_power 模块的源文件和头文件, 设置到指定变量名 MY_POWER_FILES 中# source_group(common/math FILES ${MY_POWER_FILES}) # 将 my_power 的源文件和头文件分组到 common/math 组里# 将变量 ALL_SRCS 设置为 main.cpp + MY_POWER_FILESset(ALL_SRCS main.cpp ${MY_POWER_FILES})add_executable(demo ${ALL_SRCS}) 如果希望在 解决方案资源管理器 也对文件按模块分组，那么可以添加 source_group 指令: source_group(common/math FILES ${MY_POWER_FILES}), 效果如下: 12345678910111213解决方案 'Demo2'(3 个项目)- ALL_BUILD- demo - 引用 - 外部依赖项 - common - math - my_power.cpp - my_power.h - Source Files - main.cpp - CMakeLists.txt- ZERO_CHECK 注意： 在添加 source_group 函数并重新执行 cmake .. 后，VS 不会提示重新加载解决方案，需要关闭 VS 重新打开项目. [CMake 笔记] CMake 向解决方案添加源文件兼头文件 CMAKE（3）—— aux_source_directory 包含目录下所有文件以及自动构建系统 CMake » Documentation » cmake-commands(7) » aux_source_directory 初识 CMake，如何编写一个 CMake 工程（上） CMakeLists.txt 语法介绍与实例演练 Demo3 - 多目录模块化编译 本项目演示如何管理多个目录下的文件, 文件结构如下: 12345678Demo3| CMakeLists.txt| main.cpp\\---math CMakeLists.txt my_power.cpp my_power.h 事实上，如果仅仅是简单的将文件分目录存放，那么 Demo2 中的方法也够用了.本项目在子目录 math/ 下也新建了一个 CMakeLists.txt 用来管理子目录下的文件，然后在上层目录下的 CMakeLists.txt 里面调用它. 注意：子路径下 CMakeLists.txt 中的变量名在上层 CMakeLists.txt 里面不再有效。 两个文件分别如下所示: 1234# math/CMakeLists.txtfile(GLOB MY_POWER_FILES &quot;my_power.cpp&quot; &quot;my_power.h&quot;) # 将 my_power 模块的源文件和头文件, 设置到指定变量名 MY_POWER_FILES 中add_library(my_power ${MY_POWER_FILES}) # 将本目录下的文件编译成静态库 12345678910# CMakeLists.txt...# 编译其他目录下的文件，如 mathadd_subdirectory(math)# 编译当前目录下的文件add_executable(demo main.cpp)# 把其他目录下的静态、动态库链接进来target_link_libraries(demo my_power) 注意子目录下的 CMakeLists.txt 不需要也不可以指定 cmake 的版本要求和工程名.子目录下的 CMakeLists.txt 将my_power.cpp/.h编译成静态链接库，然后再将其链接到目标 demo 上. 由于是静态库，最后编译得到的目标 demo.exe 是可以单独运行的. 生成的 VS 解决方案资源管理器如下: 12345678910111213141516171819202122解决方案 'Demo3'(4 个项目)- ALL_BUILD- demo - 引用 - 外部依赖项 - iostream - stdio.h - stdlib.h - my_power.h ... - Source Files - main.cpp - CMakeLists.txt- my_power - 引用 - 外部依赖项 - Header Files - my_power.h - Source Files - my_power.cpp - CMakeLists.txt- ZERO_CHECK 点击 生成解决方案 后得到如下编译输出: 123456789build+---Debug| demo.exe| demo.ilk| demo.pdb+---math \\---Debug my_power.lib my_power.pdb Demo4 - 自定义编译选项 在一个大工程中可能包含多个不同的模块，有时可能希望选择其中一些模块进行编译，而另一些模块不编译，也就是对工程进行裁剪。或者工程中的两个模块是可以相互替代的，我们希望能让用户自己选择使用哪一个模块。 要实现这种功能需要考虑两个方面: CMakeLists.txt和源代码. 在 CMakeLists.txt 中可以根据 option() 参数来决定是否执行某些 cmake 语句. 123456789101112131415option(USE_MYMATH &quot;use provided math implementation&quot; ON) # 设置为 ON 或 OFF，默认为 OFFmessage(STATUS &quot;USE_MYMATH is ${USE_MYMATH}&quot;)...# 是否加入 math 目录下的模块if (USE_MYMATH) # include_directories(&quot;${PROJECT_SOURCE_DIR}/math&quot;) add_subdirectory(math) # 编译其他文件夹的源代码 set(EXTRA_LIBS ${EXTRA_LIBS} my_power)endif(USE_MYMATH)# 编译当前目录下的文件add_executable(demo main.cpp)# 把其他目录下的静态、动态库链接进来target_link_libraries(demo ${EXTRA_LIBS}) 已定义 option 选项会缓存在 CMakeCache.txt 中, 除非在命令行通过 -D 参数显式地执行cmake .. -DUSE_MYMATH=OFF/ON, 或者删除缓存文件，否则配置一次后就不再改变(即便修改CMakeLists.txt). 当 USE_MYMATH 为OFF时，编译目标没有链接到 my_power 库，无法使用自己定义的函数，因此源码中必然需要进行相应的修改。为了更通用，cmake 提供了 configure_file() 函数，可以在执行 cmake .. 时根据 option() 参数将一个 config.h.in 文件转换为头文件config.h.123456789# CMakeLists.txt...# 加入一个配置头文件 config.h.in，用于编译选项的设置，注意这个文件必须用户提前建立，否则编译错误 -- 找不到该文件configure_file( &quot;${PROJECT_SOURCE_DIR}/config.h.in&quot; &quot;${PROJECT_BINARY_DIR}/config.h&quot;)include_directories(&quot;${PROJECT_BINARY_DIR}&quot;)... 注意, config.h.in是自己编写的, 如下 12// 表示启用宏名 USE_MYMATH，而且会在 config.h 中自动加入对应代码#cmakedefine USE_MYMATH 而 build/config.h 是 cmake 自动生成的，根据 USE_MYMATH 取值不同而不同 当 USE_MYMATH 为ON: 12// 表示启用宏名 USE_MYMATH，而且会在 config.h 中自动加入对应代码#define USE_MYMATH 当 USE_MYMATH 为OFF: 12// 表示启用宏名 USE_MYMATH，而且会在 config.h 中自动加入对应代码/* #undef USE_MYMATH */ 因此可以在 main.cpp 中根据是否定义了 USE_MYMATH 宏，来使用不同的代码参与运算.注意在 main.cpp 中要 #include &quot;config.h&quot;, 因此需要让编译器知道该头文件的位置，在CMakeLists.txt 中需要添加头文件路径include_directories(&quot;${PROJECT_BINARY_DIR}&quot;). 123456789101112131415161718// main.cpp#include &quot;config.h&quot;#ifdef USE_MYMATH #include &quot;math/my_power.h&quot;#else #include &lt;math.h&gt;#endif...#ifdef USE_MYMATH printf(&quot;Now we use our own Math library. \\n&quot;); double result = my_power(base, exponent);#else printf(&quot;Now we use the standard library. \\n&quot;); double result = pow(base, exponent);#endif CMake » Documentation » cmake-commands(7) » configure_file Demo5 - 安装和测试 安装 设置安装目录 安装目录由 CMAKE_INSTALL_PREFIX 指定，windows 下默认为CMAKE_INSTALL_PREFIX=C:/Program Files (x86)/${PROJECT_NAME} 要修改安装目录可以直接在 CMakeLists.txt 中通过 set() 指令实现:set(CMAKE_INSTALL_PREFIX ${PROJECT_SOURCE_DIR}/install) 后续所有 install() 指令安装的目标路径都是相对于 CMAKE_INSTALL_PREFIX 的. 安装文件 所谓 安装 实际上就是把编译生成的文件拷贝到安装目录中，整合成一个可以直接运行的软件包.本例程文件结构如下: 12345678Demo5| CMakeLists.txt| main.cpp\\---math CMakeLists.txt my_power.cpp my_power.h 首先安装子目录下的库 子目录 math/ 中有头文件，并且在 CMakeLists.txt 中还设置了要生成库文件. 这两部分需要被安装到指定目录中去.修改math/CMakeLists.txt 1234567# math/CMakeLists.txt...# 指定 my_power 库的安装路径install(TARGETS my_power DESTINATION bin)install(FILES my_power.h DESTINATION include) 安装编译目标和相关头文件 修改CMakeLists.txt 12345678# CMakeLists.txt...# 指定 demo.exe 安装路径install(TARGETS demo DESTINATION bin)install(FILES &quot;${PROJECT_BINARY_DIR}/config.h&quot; DESTINATION include) 执行 cmake .. 之后通过 VS 打开解决方案，可以看到解决方案资源管理器如下所示 12345678910111213141516171819202122232425解决方案 'Demo5'(5 个项目)- ALL_BUILD- demo - 引用 - 外部依赖项 - config.h - my_power.h ... - Source Files - main.cpp - CMakeLists.txt- INSTALL - 引用 - 外部依赖项 - CMake Rules - INSTALL_force.rule- my_power - 引用 - 外部依赖项 - Header Files - my_power.h - Source Files - my_power.cpp - CMakeLists.txt- ZERO_CHECK 其中 INSTALL 项目就是用于安装的, 在直接点击 生成解决方案 时会被跳过，输出如下: 1234...5&gt;------ 已跳过生成: 项目: INSTALL, 配置: Debug Win32 ------5&gt; 没有为此解决方案配置选中要生成的项目 ========== 生成: 成功 4 个，失败 0 个，最新 0 个，跳过 1 个 ========== 此时如果要安装，需要选中 INSTALL 项目，右键，点击 生成, 输出如下, 表示相关文件已经被拷贝到了对应的目录中了: 12345671&gt;------ 已启动生成: 项目: INSTALL, 配置: Debug Win32 ------1&gt;-- Install configuration: &quot;Debug&quot;1&gt;-- Installing: &lt;path&gt;/Demo5/install/bin/my_power.lib1&gt;-- Installing: &lt;path&gt;/Demo5/install/include/my_power.h1&gt;-- Installing: &lt;path&gt;/Demo5/install/bin/demo.exe1&gt;-- Installing: &lt;path&gt;/Demo5/install/include/config.h========== 生成: 成功 1 个，失败 0 个，最新 4 个，跳过 0 个 ========== 可以查看 install 目录如下: 12345678Demo5\\install+---bin| demo.exe| my_power.lib|\\---include config.h my_power.h 测试 为了验证代码正确性，可以事先给出几个样例，在生成目标后运行测试样例，判断其输出是否正确, 从而判断程序是否正确.CMake提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists.txt 文件中调用一系列的 add_test() 命令. 要添加测试，首先在 CMakeLists.txt 中添加: enable_testing()然后就可以通过 add_test(&lt;name&gt; &lt;command&gt; [&lt;arg&gt;...]) 来添加测试. 其中 &lt;name&gt; 可以随便，但不要重复；&lt;command&gt;是编译生成的目标文件, 后面 &lt;arg&gt; 给出可执行文件需要的参数. 测试程序是否可以运行: add_test (test_run demo 5 2) 测试帮助信息是否可以正常提示 123add_test (test_usage demo) # 测试时不指定参数，main 函数中会检查发现参数个数不对，然后输出帮助信息set_tests_properties (test_usagePROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;) # 通过正则表达式检查程序输出是否正确 测试 5 的平方 123add_test (test_5_2 demo 5 2) # 测试时指定参数 5 和 2，程序会计算 5^2, 然后在终端输出set_tests_properties (test_5_2PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;) # 通过正则表达式检查程序输出是否正确 如果要执行更多的测试样例，使用 add_test() 效率就太低了，可以通过编写宏来简化操作: 1234567891011# 定义一个宏，用来简化测试工作macro (do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} demo ${arg1} ${arg2}) set_tests_properties (test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result})endmacro (do_test) # 使用该宏进行一系列的数据测试do_test (5 2 &quot;is 25&quot;)do_test (10 5 &quot;is 100000&quot;)do_test (2 10 &quot;is 1024&quot;) 执行 cmake .. 之后通过 VS 打开解决方案，可以看到解决方案资源管理器如下所示 1234567891011121314解决方案 'Demo5'(6 个项目)- ALL_BUILD- demo ...- INSTALL ...- RUN_TESTS - 引用 - 外部依赖项 - CMake Rules - RUN_TESTS_force.rule- my_power ...- ZERO_CHECK 其中 RUN_TESTS 项目就是用于测试的, 在直接点击 生成解决方案 时会被跳过，需要在生成解决方案之后单独生成一次，输出如下: 12345678910111213141516171819202122231&gt;------ 已启动生成: 项目: RUN_TESTS, 配置: Debug Win32 ------1&gt;Test project &lt;path&gt;/Demo5/build1&gt; Start 1: test_run1&gt;1/8 Test #1: test_run ......................... Passed 0.02 sec1&gt; Start 2: test_usage1&gt;2/8 Test #2: test_usage ....................... Passed 0.01 sec1&gt; Start 3: test_5_21&gt;3/8 Test #3: test_5_2 ......................... Passed 0.01 sec1&gt; Start 4: test_10_51&gt;4/8 Test #4: test_10_5 ........................ Passed 0.01 sec1&gt; Start 5: test_2_101&gt;5/8 Test #5: test_2_10 ........................ Passed 0.01 sec1&gt; Start 6: test_5_31&gt;6/8 Test #6: test_5_3 ......................... Passed 0.02 sec1&gt; Start 7: test_10_21&gt;7/8 Test #7: test_10_2 ........................ Passed 0.01 sec1&gt; Start 8: test_2_51&gt;8/8 Test #8: test_2_5 ......................... Passed 0.01 sec1&gt;1&gt;100% tests passed, 0 tests failed out of 81&gt;1&gt;Total Test time (real) = 0.20 sec========== 生成: 成功 1 个，失败 0 个，最新 1 个，跳过 0 个 ========== CMake » Documentation » cmake-commands(7) » add_test Demo6 - 添加版本号 1234567 版本格式：主版本号. 次版本号. 修订号，版本号递增规则如下： 1. 主版本号：当你做了不兼容的 API 修改， 2. 次版本号：当你做了向下兼容的功能性新增， 3. 修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号. 次版本号. 修订号”的后面，作为延伸。 语义化版本 2.0.0 要在 CMakeLists.txt 中指定版本号只需在设置工程名时顺带用 VERSION 属性设置即可: 12345project(Demo6 VERSION 0.1.0 # 语义化版本 https://semver.org/lang/zh-CN/ DESCRIPTION &quot;demo project&quot; # CMake&gt;=3.9 才可以使用 DESCRIPTION LANGUAGES CXX) 这里虽然只设置了一个属性VERSION，但同时如下四个变量会被 cmake 自动进行设置. 1234${PROJECT_NAME}_VERSION${PROJECT_NAME}_VERSION_MAJOR${PROJECT_NAME}_VERSION_MINOR${PROJECT_NAME}_VERSION_PATCH 可以通过 message() 来查看它们的值: 12345# 查看程序版本是否设置正确message(STATUS &quot;${PROJECT_NAME}_VERSION=${${PROJECT_NAME}_VERSION}&quot;)message(STATUS &quot;${PROJECT_NAME}_VERSION_MAJOR=${${PROJECT_NAME}_VERSION_MAJOR}&quot;)message(STATUS &quot;${PROJECT_NAME}_VERSION_MINOR=${${PROJECT_NAME}_VERSION_MINOR}&quot;)message(STATUS &quot;${PROJECT_NAME}_VERSION_PATCH=${${PROJECT_NAME}_VERSION_PATCH}&quot;) 执行 cmake .. 时终端输出如下: 123456PS &lt;path&gt;\\Demo6\\build&gt; cmake ..-- Selecting Windows SDK version 10.0.17763.0 to target Windows 10.0.19044.-- Demo6_VERSION=0.1.0-- Demo6_VERSION_MAJOR=0-- Demo6_VERSION_MINOR=1-- Demo6_VERSION_PATCH=0 如果希望在 *.cpp 源文件也能访问到这些变量，可以通过编写 Version.h.in 并用 configure_file() 指令实现, 此处略.可参考如下资料: CMake 入门实战 Modern CMake 简体中文版 » 基础知识简介 » 与你的代码交互 Demo7 - 生成安装包(未实现) 本项目学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。 首先在顶层的 CMakeLists.txt 文件尾部添加下面几行： 123456789# 构建一个 CPack 安装包include (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE &quot;${CMAKE_CURRENT_SOURCE_DIR}/LICENSE&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;${${PROJECT_NAME}_VERSION_MAJOR}&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;${${PROJECT_NAME}_VERSION_MINOR}&quot;)set (CPACK_PACKAGE_VERSION_PATCH &quot;${${PROJECT_NAME}_VERSION_PATCH}&quot;)include (CPack) 上面的代码做了以下几个工作： 导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块； 设置一些 CPack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号； 导入 CPack 模块 执行 cmake .. 后用 vs 打开解决方案，点击生成解决方案，然后单独生成 INSTALL 项目，单独生成 PACKAGE 项目 123456789101112解决方案 'Demo7'(7 个项目)- ALL_BUILD- demo- INSTALL- RUN_TESTS- PACKAGE - 引用 - 外部依赖项 - CMake Rules - PACKAGE_force.rule- my_power- ZERO_CHECK 终端输出如下, 似乎是没有安装NSIS(该问题暂未解决, 先搁置): 12341&gt;------ 已启动生成: 项目: PACKAGE, 配置: Debug Win32 ------1&gt;EXEC : CPack error : Cannot find NSIS compiler makensis: likely it is not installed, or not in your PATH1&gt;EXEC : CPack error : Could not read NSIS registry value. This is usually caused by NSIS not being installed. Please install NSIS from http://nsis.sourceforge.net1&gt;EXEC : CPack error : Cannot initialize the generator NSIS 参考: CMake 入门实战 Modern CMake 简体中文版 » Exporting and Installing » Packaging Demo8 - 编写 FindXXX.cmake(待完善)如果要在自己的项目中引用第三方库，可以通过 find_package(pkg-name) 来方便地实现，例如 OpenCV 和PCL等常用库都提供了相应的 OpenCVConfig.cmake 和PCLConfig.cmake, 调用者只需要让 CMake 能找到这类文件的路径即可方便地调用.但有些小众的第三方库可能并没有提供这类文件，或者自己编写的某些简单的库没有提供相应的文件，为了通过 cmake 调用，可以编写一个 FindXXX.cmake 来帮助查找库文件，从而将库的查找与使用进行解耦。 本项目包含两个部分: export和 import. 其中export 部分负责编译生成库文件，而 import 部分通过 Findxxx.cmake 的形式来引用这些库. 生成库 使用库 当移动了 MyMath 库的路径之后，只需要修改 cmake/FindMyMath.cmake 中的 MyMath_ROOT_DIR 即可. 如何为 cmake 提供 package 以便于 find_package, 以及用 VCPKG 补充 CMake 实现快速下载集成 Demo9 - 为自己的库生成 XXXConfig.cmake 项目文件结构 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758D:\\RESEARCH\\MACHINEVISION\\CODE\\LEARN_CMAKE\\CODES\\DEMO9+---export| | CMakeLists.txt| | Config.cmake.in| | LICENSE| || +---build| +---install| | +---bin| | | test_myplus.exe| | | test_mypower.exe| | || | +---cmake| | | MyMathConfig.cmake| | | MyMathConfigVersion.cmake| | | myplusTargets-debug.cmake| | | myplusTargets.cmake| | | mypowerTargets-debug.cmake| | | mypowerTargets.cmake| | || | +---include| | | myplus.h| | | mypower.h| | || | \\---lib| | myplus.lib| | mypower.lib| || +---mymath| | +---myplus| | | myplus.cpp| | || | \\---mypower| | mypower.cpp| | mypower.h| || \\---samples| +---myplus| | test_myplus.cpp| || \\---mypower| test_mypower.cpp|\\---import | CMakeLists.txt | +---build +---install | \\---bin | test_myplus.exe | test_mypower.exe | \\---samples +---myplus | test_myplus.cpp | \\---mypower test_mypower.cpp CMake Tutorial: Code Step 11: Adding Export Configuration CMakePackageConfigHelpers Modern CMake: Exporting and Installing 如何为 cmake 提供 package 以便于 find_package, 以及用 VCPKG 补充 CMake 实现快速下载集成 CMake 库打包以及支持 find_package Demo10 - 通过 CMake 管理 Qt GUI 项目 Get started with CMake - doc.qt.io Build with CMake cmake-qt(7) CMake Introduction CMake 管理 C/C++ 工程的一点心得 在 Qt 项目中调用 OpenCV: 访问 usb 摄像头并实时绘制到 QLabel (CMake + VSCode) Using CMake with Qt 5 Qt and CMake: The Past, the Present and the Future 参考 Modern CMake 简体中文版 An Introduction to Modern CMake CMake 3.18 Documentation CMake Tutorial CMake 入门实战 ve2102388688/myCmakeDemos - Github BrightXiaoHan/CMakeTutorial - Github CMake Tutorial - ltslam-doc CMake 教程 - CSDN C++ 工程目录结构规范示例 - Github","link":"/blogs/cmake/"},{"title":"Umeyama 算法求解相似变换","text":"Kabsch–Umyama 算法是一种对齐和比较两组点之间的相似性的方法。它通过最小化点对的根平方偏差（RMSD）来找到最佳的平移，旋转和缩放。Kabsch(1976,1978) 首先描述了寻找最佳旋转的算法。Umeyama(1991) 提出了类似方法，该方法除旋转外还支持平移和缩放。 求 $c$, $\\mathbf{R}$, $\\mathbf{t}$ 使得下式最小:$$ \\frac{1}{n} \\sum_{i=1}^n \\vert\\vert y_i - (c\\mathbf{R}x_i + \\mathbf{t}) \\vert\\vert_2^2$$ 注: 该问题与 Fusiello(2015) 附录 A 中提到的扩展正交普氏分析 (Extended Orthogonal Procrustes Analysis) 实际上是同一概念。 相关文献 Kabsch, W. (1976). “A solution for the best rotation to relate two sets of vectors”. Acta Crystallographica. A32 (5): 922–923. doi:10.1107/S0567739476001873. Kabsch, W. (1978). “A discussion of the solution for the best rotation to relate two sets of vectors”. Acta Crystallographica. A34 (5): 827–828. doi:10.1107/S0567739478001680 Umeyama, S. (1991). “Least-squares estimation of transformation parameters between two point patterns”. IEEE Transactions on Pattern Analysis and Machine Intelligence. 13 (4): 376–380. doi:10.1109/34.88573. Lawrence, J. , Bernal, J. and Witzgall, C. (2019). “A Purely Algebraic Justification of the Kabsch-Umeyama Algorithm”. Journal of Research (NIST JRES), National Institute of Standards and Technology, Gaithersburg, MD. doi:10.6028/jres.124.028 A. Fusiello, F. Crosilla and F. Malapelle, “Procrustean Point-Line Registration and the NPnP Problem,” 2015 International Conference on 3D Vision, 2015, pp. 250-255, doi:10.1109/3DV.2015.35. 其他博客 Aligning point patterns with Kabsch–Umeyama algorithm Umeyama 算法 - 微博 算法实现 evo/evo/core/geometry.py#umeyama_alignment Eigen Documentation &gt;&gt; Eigen::umeyama() Eigen::umeyama 函数实现: Eigen\\src\\Geometry\\Umeyama.h https://gitlab.com/libeigen/eigen/-/blob/master/Eigen/src/Geometry/Umeyama.h#L95-L164 调用 Eigen::umeyama(): rigid_transformation3D_srt.cpp 刚体变换 (不支持缩放): https://github.com/cgraumann/umeyama-matlab 代码 C++ EigenEigen/src/Geometry/Umeyama.h >foldedlink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// This file is part of Eigen, a lightweight C++ template library// for linear algebra.//// Copyright (C) 2009 Hauke Heibel &lt;hauke.heibel@gmail.com&gt;//// This Source Code Form is subject to the terms of the Mozilla// Public License v. 2.0. If a copy of the MPL was not distributed// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.#ifndef EIGEN_UMEYAMA_H#define EIGEN_UMEYAMA_H// This file requires the user to include // * Eigen/Core// * Eigen/LU // * Eigen/SVD// * Eigen/Array#include &quot;./InternalHeaderCheck.h&quot;namespace Eigen { #ifndef EIGEN_PARSED_BY_DOXYGEN// These helpers are required since it allows to use mixed types as parameters// for the Umeyama. The problem with mixed parameters is that the return type// cannot trivially be deduced when float and double types are mixed.namespace internal {// Compile time return type deduction for different MatrixBase types.// Different means here different alignment and parameters but the same underlying// real scalar type.template&lt;typename MatrixType, typename OtherMatrixType&gt;struct umeyama_transform_matrix_type{ enum { MinRowsAtCompileTime = internal::min_size_prefer_dynamic(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime), // When possible we want to choose some small fixed size value since the result // is likely to fit on the stack. So here, min_size_prefer_dynamic is not what we want. HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1 }; typedef Matrix&lt;typename traits&lt;MatrixType&gt;::Scalar, HomogeneousDimension, HomogeneousDimension, AutoAlign | (traits&lt;MatrixType&gt;::Flags &amp; RowMajorBit ? RowMajor : ColMajor), HomogeneousDimension, HomogeneousDimension &gt; type;};}#endif/*** \\geometry_module \\ingroup Geometry_Module** \\brief Returns the transformation between two point sets.** The algorithm is based on:* &quot;Least-squares estimation of transformation parameters between two point patterns&quot;,* Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573** It estimates parameters \\f$ c, \\mathbf{R}, \\f$ and \\f$ \\mathbf{t} \\f$ such that* \\f{align*}* \\frac{1}{n} \\sum_{i=1}^n \\vert\\vert y_i - (c\\mathbf{R}x_i + \\mathbf{t}) \\vert\\vert_2^2* \\f}* is minimized.** The algorithm is based on the analysis of the covariance matrix* \\f$ \\Sigma_{\\mathbf{x}\\mathbf{y}} \\in \\mathbb{R}^{d \\times d} \\f$* of the input point sets \\f$ \\mathbf{x} \\f$ and \\f$ \\mathbf{y} \\f$ where * \\f$d\\f$ is corresponding to the dimension (which is typically small).* The analysis is involving the SVD having a complexity of \\f$O(d^3)\\f$* though the actual computational effort lies in the covariance* matrix computation which has an asymptotic lower bound of \\f$O(dm)\\f$ when * the input point sets have dimension \\f$d \\times m\\f$.** Currently the method is working only for floating point matrices.** \\todo Should the return type of umeyama() become a Transform?** \\param src Source points \\f$ \\mathbf{x} = \\left(x_1, \\hdots, x_n \\right) \\f$.* \\param dst Destination points \\f$ \\mathbf{y} = \\left(y_1, \\hdots, y_n \\right) \\f$.* \\param with_scaling Sets \\f$ c=1 \\f$ when &lt;code&gt;false&lt;/code&gt; is passed.* \\return The homogeneous transformation * \\f{align*}* T = \\begin{bmatrix} c\\mathbf{R} &amp; \\mathbf{t} \\\\ \\mathbf{0} &amp; 1 \\end{bmatrix}* \\f}* minimizing the residual above. This transformation is always returned as an * Eigen::Matrix.*/template &lt;typename Derived, typename OtherDerived&gt;typename internal::umeyama_transform_matrix_type&lt;Derived, OtherDerived&gt;::typeumeyama(const MatrixBase&lt;Derived&gt;&amp; src, const MatrixBase&lt;OtherDerived&gt;&amp; dst, bool with_scaling = true){ typedef typename internal::umeyama_transform_matrix_type&lt;Derived, OtherDerived&gt;::type TransformationMatrixType; typedef typename internal::traits&lt;TransformationMatrixType&gt;::Scalar Scalar; typedef typename NumTraits&lt;Scalar&gt;::Real RealScalar; EIGEN_STATIC_ASSERT(!NumTraits&lt;Scalar&gt;::IsComplex, NUMERIC_TYPE_MUST_BE_REAL) EIGEN_STATIC_ASSERT((internal::is_same&lt;Scalar, typename internal::traits&lt;OtherDerived&gt;::Scalar&gt;::value), YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) enum { Dimension = internal::min_size_prefer_dynamic(Derived::RowsAtCompileTime, OtherDerived::RowsAtCompileTime) }; typedef Matrix&lt;Scalar, Dimension, 1&gt; VectorType; typedef Matrix&lt;Scalar, Dimension, Dimension&gt; MatrixType; typedef typename internal::plain_matrix_type_row_major&lt;Derived&gt;::type RowMajorMatrixType; const Index m = src.rows(); // dimension const Index n = src.cols(); // number of measurements // required for demeaning ... const RealScalar one_over_n = RealScalar(1) / static_cast&lt;RealScalar&gt;(n); // computation of mean const VectorType src_mean = src.rowwise().sum() * one_over_n; const VectorType dst_mean = dst.rowwise().sum() * one_over_n; // demeaning of src and dst points const RowMajorMatrixType src_demean = src.colwise() - src_mean; const RowMajorMatrixType dst_demean = dst.colwise() - dst_mean; // Eq. (38) const MatrixType sigma = one_over_n * dst_demean * src_demean.transpose(); JacobiSVD&lt;MatrixType, ComputeFullU | ComputeFullV&gt; svd(sigma); // Initialize the resulting transformation with an identity matrix... TransformationMatrixType Rt = TransformationMatrixType::Identity(m+1,m+1); // Eq. (39) VectorType S = VectorType::Ones(m); if (svd.matrixU().determinant() * svd.matrixV().determinant() &lt; 0 ) S(m-1) = -1; // Eq. (40) and (43) Rt.block(0,0,m,m).noalias() = svd.matrixU() * S.asDiagonal() * svd.matrixV().transpose(); if (with_scaling) { // Eq. (36)-(37) const Scalar src_var = src_demean.rowwise().squaredNorm().sum() * one_over_n; // Eq. (42) const Scalar c = Scalar(1)/src_var * svd.singularValues().dot(S); // Eq. (41) Rt.col(m).head(m) = dst_mean; Rt.col(m).head(m).noalias() -= c*Rt.topLeftCorner(m,m)*src_mean; Rt.block(0,0,m,m) *= c; } else { Rt.col(m).head(m) = dst_mean; Rt.col(m).head(m).noalias() -= Rt.topLeftCorner(m,m)*src_mean; } return Rt;}} // end namespace Eigen#endif // EIGEN_UMEYAMA_H C++ OpenCVestimateRigidTransform3D_srt()>folded1234567891011121314151617181920212223242526272829303132333435363738// 计算多个三维点对之间的最优相似变换矩阵 // estimate R,t s.t. a*R*src + t = dst// src,dst 为 n 行 3 列矩阵, 每行都是一个点的三维坐标 // 如果 scale==1, 则默认没有缩放, 缩放为 1; 否则使用估计的缩放因子 // https://www.cnblogs.com/wqj1212/p/3915859.html// https://github.com/opencv/opencv/blob/478663b08c2050546d06b4d3586386954343f80b/modules/video/include/opencv2/video/tracking.hpp#L258// https://github.com/opencv/opencv/blob/828304d587b3a204ebc34ce8573c3adec5a41ad2/modules/video/src/lkpyramid.cpp#L1508double estimateRigidTransform3D_srt(const cv::Mat&amp; src, const cv::Mat&amp; dst, double scale, cv::Mat&amp; R, cv::Mat&amp; t){ CV_Assert(src.rows == dst.rows); CV_Assert((src.cols == 3) &amp;&amp; (dst.cols == 3)); int n = src.rows; cv::Mat e = cv::Mat::ones(n, 1, CV_64F); cv::Mat II = cv::Mat::eye(n, n, CV_64F) - cv::Mat::ones(n, n, CV_64F) / n; cv::Mat U, Sigma, Vt; cv::SVD::compute(dst.t()*II*src, Sigma, U, Vt); cv::Mat Sigma_det = cv::Mat::eye(3, 3, CV_64F); Sigma_det.at&lt;double&gt;(2, 2) = cv::determinant(U*Vt); R = U * Sigma_det*Vt; cv::Mat AR = dst * R; double a; if (scale == 1) { a = 1; } else { a = cv::trace(dst.t()*II*dst).val[0] / cv::trace(AR.t()*II*src).val[0]; } cv::Mat c_trans; cv::reduce(a*src - AR, c_trans, 0, CV_REDUCE_AVG);// 逐列求均值 cv::Mat c = c_trans.t(); t = -R * c; cv::Mat Y = a * src - dst * R - e * c_trans; double err = cv::norm(Y) / sqrt(n); return err;} Pythonumeyama.py >foldedlink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# umeyama function from scikit-image/skimage/transform/_geometric.pyimport numpy as npdef umeyama( src, dst, estimate_scale ): &quot;&quot;&quot;Estimate N-D similarity transformation with or without scaling. Parameters ---------- src : (M, N) array Source coordinates. dst : (M, N) array Destination coordinates. estimate_scale : bool Whether to estimate scaling factor. Returns ------- T : (N + 1, N + 1) The homogeneous similarity transformation matrix. The matrix contains NaN values only if the problem is not well-conditioned. References ---------- .. [1] &quot;Least-squares estimation of transformation parameters between two point patterns&quot;, Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573 &quot;&quot;&quot; num = src.shape[0] dim = src.shape[1] # Compute mean of src and dst. src_mean = src.mean(axis=0) dst_mean = dst.mean(axis=0) # Subtract mean from src and dst. src_demean = src - src_mean dst_demean = dst - dst_mean # Eq. (38). A = np.dot(dst_demean.T, src_demean) / num # Eq. (39). d = np.ones((dim,), dtype=np.double) if np.linalg.det(A) &lt; 0: d[dim - 1] = -1 T = np.eye(dim + 1, dtype=np.double) U, S, V = np.linalg.svd(A) # Eq. (40) and (43). rank = np.linalg.matrix_rank(A) if rank == 0: return np.nan * T elif rank == dim - 1: if np.linalg.det(U) * np.linalg.det(V) &gt; 0: T[:dim, :dim] = np.dot(U, V) else: s = d[dim - 1] d[dim - 1] = -1 T[:dim, :dim] = np.dot(U, np.dot(np.diag(d), V)) d[dim - 1] = s else: T[:dim, :dim] = np.dot(U, np.dot(np.diag(d), V.T)) if estimate_scale: # Eq. (41) and (42). scale = 1.0 / src_demean.var(axis=0).sum() * np.dot(S, d) else: scale = 1.0 T[:dim, dim] = dst_mean - scale * np.dot(T[:dim, :dim], src_mean.T) T[:dim, :dim] *= scale return T MatlabestimateRigidTransform3D_srt.m >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344% initclc;clear;close all;%% Test 坐标系 A 坐标系 Bpoint_A = [0, -2.14185, -1.1497 0,-1.6855,-1.1068 -0.24,-1.6905,-1.0969 0,-0.473,-1.146]point_B = [-0.9121385,-0.5697752,1.051605 -0.4756734,-0.5859144,1.152362 -0.5229784,-0.6114097,1.401835 0.6978357,-0.5654929,1.69446][n,~] = size(point_A)[R,t] = estimateRigidTransform3D_srt(point_A, point_B)error = R*point_A.' + t*ones(1,n) - point_B.'err = vecnorm(error)figure(1);S_transformed = R*point_A.' + t*ones(1,n);S_transformed = S_transformed.';plot3(point_A(:,1),point_A(:,2),point_A(:,3),'bd','MarkerSize',5);hold on;plot3(point_B(:,1),point_B(:,2),point_B(:,3),'bd','MarkerSize',5);hold on;plot3(S_transformed(:,1),S_transformed(:,2),S_transformed(:,3),'b*','MarkerSize',5);hold on;grid on;axis square;%% implementfunction [R, t, a] = estimateRigidTransform3D_srt(Src, Dst)% same usage as gPPnPunit_scale = (nargout &lt;3);n = size(Src,1);e = ones(n,1); II = eye(n)-((e*e')./n);[U,~,V] = svd((Dst)'*II*Src);R=U*[1 0 0; 0 1 0; 0 0 det(U*V')]*V';A = Dst; AR=A*R;if unit_scale a=1;else a = trace((A)'*II*(A))/trace(AR'*II*Src);endc = mean((a*Src-AR),1)';t = -R*c;end","link":"/blogs/umeyama/"},{"title":"Tips","text":"各类操作技巧整理 PowerShell 安装 Pscx 插件以支持命令行的完整功能, 例如 指定文件树深度 Pscx 插件官网 Win10 Powershell 实现类似 Linux 指定 tree 命令展示深度 安装 Pscx 插件1&gt; Install-Module -Name Pscx -RequiredVersion 3.2.2 -Scope CurrentUser -AllowClobber 该插件支持了一个比较完整的 tree 指令，查看文件树可以指定深度 12&gt; Show-Tree [[-Path] &lt;String[]&gt;] [[-Depth] &lt;Int32&gt;] # 命令用法&gt; Show-Tree dir -Depth 2 # 命令示例 Linux 中给 coreutils 打补丁，使得执行 cp 和 mv 指令时可以显示 进度条 给 cp 和 mv 命令添加进度条 12345678910111213141516171819# 注意尽量不要使用 root 用户操作# 下载 coreutils$ wget http://ftp.gnu.org/gnu/coreutils/coreutils-8.32.tar.xz$ tar -xJf coreutils-8.32.tar.xz$ cd coreutils-8.32/# 下载 github 上的补丁$ wget https://raw.githubusercontent.com/jarun/advcpmv/master/advcpmv-0.8-8.32.patch# 打补丁，实现进度条显示$ patch -p1 -i advcpmv-0.8-8.32.patchpatching file src/copy.cpatching file src/copy.hpatching file src/cp.cpatching file src/mv.c# 编译安装$ ./configure$ make# 将打补丁生成的 cp 和 mv 命令的二进制文件复制到 bin 目录下$ sudo cp src/cp /usr/local/bin/cp$ sudo cp src/mv /usr/local/bin/mv 接着只需要在使用 cp 和 mv 命令的时候加上 -g 参数就可以显示进度条了 为了方便起见可以在 ~/.bashrc 文件中设置 alias 12alias cp='cp -ig'alias mv='mv -ig' Ubuntu 安装 hack 字体 1234567891011wget https://github.com/source-foundry/Hack/releases/download/v3.003/Hack-v3.003-ttf.zip # 下载字体文件unzip Hack-v3.003-ttf.zipsudo cp -r ttf/ /usr/share/fonts/# 下载字体配置文件sudo wget -O /etc/fonts/conf.d/45-Hack.conf https://raw.githubusercontent.com/source-foundry/Hack/master/config/fontconfig/45-Hack.conffc-cache -f -v # 清除并重新生成字体缓存和索引# fc-cache: succeeded # 终端如此显示表示刷新成功fc-list | grep &quot;Hack&quot; # 检查是否安装成功# 删除文件rm -rf ttf/rm Hack-v3.003-ttf.zip ubuntu 安装 Hack 字体 Hack 官网 source-foundry/Hack - Github 在 VS Code 中配置使用 Hack 字体 在Settings-&gt;Editor: Font Family 中修改为如下内容 1Hack, 'monospace', monospace Visual Studio 相关配置 无法查找或打开 PDB 文件 工具 -&gt; 选项 -&gt; 调试 -&gt; 常规 -&gt; 勾选 启用源服务器支持 工具 -&gt; 选项 -&gt; 调试 -&gt; 符号-&gt; 勾选 Microsoft 符号服务器 VS“无法查找或打开 PDB 文件”是怎么回事？如何解决 SDL 检查 Visual Studio 开启了 SDL 检查后，某些警告会成为错误，使程序编译不通过. 关闭SDL 检查: 属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 常规 -&gt; SDL 检查: 否(/sdl-) 安全开发生命周期检查(SDL, Security Development Lifecycle) windows 安全警告与 SDL 检查 属性表文件 创建属性表 视图 -&gt; 其他窗口 -&gt; 属性管理器 -&gt;Debug|64-&gt; 右键: 添加新项目属性表 -&gt; 右键该属性表: 属性-&gt;... 导入属性表 视图 -&gt; 其他窗口 -&gt; 属性管理器 -&gt;Debug|64-&gt; 右键: 添加现有属性表 【新手教程】Visual Studio .props 文件简介 RelWithDebInfo 这种编译模式在保留 Release 模式下运行快速的前提下，又可以给特定的工程开启 Debug 模式，进行针对性的调试。这样比整个项目都采用 Debug 模式进行编译，在调试时会提高效率。 某些工程默认情况下没有配置这种编译模式，可以在 Release 模式下修改如下配置来实现这个效果. 属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 常规 -&gt; 调试信息格式: 程序数据库(/Zi) 属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 优化 -&gt; 优化: 已禁用(/Od) 属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 优化 -&gt; 内联函数扩展: 默认值 属性 -&gt; 配置属性 -&gt; 链接器 -&gt; 调试 -&gt; 生成调试信息: 生成调试信息 (/DEBUG) Visual Studio 在 Release 模式下开启 debug 调试 Markdown以 HTML 格式插入图片并居中1234&lt;div align=center&gt; &lt;img src=&quot;./images/image1.jpg&quot; width=300&gt; &lt;img src=&quot;./images/image1.jpg&quot; width=300&gt;&lt;/div&gt; Windows 无法被 ping 通 原因是 Windows 默认开启了防火墙，可以关闭防火墙使其能够被局域网内其他设备访问，但请确保局域网内所有设备都是可信任的。 Windows 安全中心 -&gt; 防火墙和网络保护 -&gt; 专用网络 -&gt; Microsoft Defender 防火墙: 关闭","link":"/blogs/tips/"},{"title":"开源协议","text":"GitHub 开源协议详解及常用协议介绍 什么是 Apache License 2.0 开源协议","link":"/blogs/licenses/"},{"title":"Visual Studio 版本对应关系","text":"示例 Visual Studio 2022 v17.3.3 用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.33.31629 版 版本对应关系 IDE 发布时间 工具集版本 MSC_VER MSVC++ Visual C++ 6.0 1998 V60 1200 MSVC++ 6.0 Visual Studio 2002 (version 7.0) 2002 V70 1300 MSVC++ 7.0 Visual Studio 2003 (version 7.1) 2003 V71 1310 MSVC++ 7.1 Visual Studio 2005 (version 8.0) 2005 V80 1400 MSVC++ 8.0 Visual Studio 2008 (version 9.0) 2008 V90 1500 MSVC++ 9.0 Visual Studio 2010 (version 10.0) 2010 V100 1600 MSVC++ 10.0 Visual Studio 2012 (version 11.0) 2012 V110 1700 MSVC++ 11.0 Visual Studio 2013 (version 12.0) 2013 V120 1800 MSVC++ 12.0 Visual Studio 2015 (version 14.0) 2015 V140 1900 MSVC++ 14.0 Visual Studio 2017 (versions 15.0 + 15.1 + 15.2) 2017 V141 1910 MSVC++ 14.1 Visual Studio 2017 (version 15.3) V141 1911 MSVC++ 14.11 Visual Studio 2017 (version 15.5) V141 1912 MSVC++ 14.12 Visual Studio 2017 (Version 15.6) V141 1913 MSVC++ 14.13 Visual Studio 2017 (version 15.7) V141 1914 MSVC++ 14.14 Visual Studio 2017 (version 15.8) V141 1915 MSVC++ 14.15 Visual Studio 2017 (version 15.9) V141 1916 MSVC++ 14.16 Visual Studio 2019 (version 16.0) 2019 V142 1920 MSVC++ 14.20 Visual Studio 2019 (version 16.1) V142 1921 MSVC++ 14.21 Visual Studio 2019 (version 16.2) V142 1922 MSVC++ 14.22 Visual Studio 2019 (version 16.3) V142 1923 MSVC++ 14.23 Visual Studio 2019 (version 16.4) V142 1924 MSVC++ 14.24 Visual Studio 2019 (version 16.5) V142 1925 MSVC++ 14.25 Visual Studio 2019 (version 16.6) V142 1926 MSVC++ 14.26 Visual Studio 2019 (version 16.7) V142 1927 MSVC++ 14.27 Visual Studio 2019 (versions 16.8 + 16.9) V142 1928 MSVC++ 14.28 Visual Studio 2019 (versions 16.10 + 16.11) V142 1929 MSVC++ 14.29 Visual Studio 2022 (version 17.0) 2022 V143 1930 MSVC++ 14.30 Visual Studio 2022 (version 17.1) V143 1931 MSVC++ 14.31 Visual Studio 2022 (version 17.2) V143 1932 MSVC++ 14.32 Visual Studio 2022 (version 17.3) V143 1933 MSVC++ 14.33 Visual Studio 2022 (version 17.4) V143 1934 MSVC++ 14.34 https://learn.microsoft.com/zh-cn/cpp/preprocessor/predefined-macros?view=msvc-170 https://en.wikipedia.org/wiki/Microsoft_Visual_C++","link":"/blogs/visualstudio/"},{"title":"OpenCV 在图片中写入中文字符","text":"OpenCV 显示中文 | 知乎 使用 OpenCV 自带的 cv::putText() 函数往图片里写入中文字符时无法正常显示，而是显示为 “???”. 要解决这个问题, 在 Windows 平台上可以调用 Windows API 里的 HDC 系列函数来完成字符绘制，封装后提供的接口为 cv::putTextZH(). cv_puttextzh.h >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150// cv::putTextZH(), the enhanced version for cv::putText, support drawing #ifndef CV_PUTTEXTZH_H#define CV_PUTTEXTZH_H#include &quot;opencv2/opencv.hpp&quot;//----------------------------------------------------------------------// declaration//----------------------------------------------------------------------namespace cv { static void putTextZH(cv::Mat&amp; dst, const char* str, cv::Point org, cv::Scalar color, int fontSize, const char* fn = &quot;Arial&quot;, bool italic = false, bool underline = false);}//----------------------------------------------------------------------// implementation//----------------------------------------------------------------------#define NOMINMAX#define WIN32_LEAN_AND_MEAN#include &lt;windows.h&gt;#undef NOMINMAX#undef WIN32_LEAN_AND_MEANstatic void GetStringSize(HDC hDC, const char* str, int* w, int* h){ SIZE size; GetTextExtentPoint32A(hDC, str, strlen(str), &amp;size); if (w != 0) *w = size.cx; if (h != 0) *h = size.cy;}namespace cv { void putTextZH(cv::Mat&amp; dst, const char* str, cv::Point org, cv::Scalar color, int fontSize, const char* fn, bool italic, bool underline) { CV_Assert(dst.data != 0 &amp;&amp; (dst.channels() == 1 || dst.channels() == 3)); int x, y, r, b; if (org.x &gt; dst.cols || org.y &gt; dst.rows) return; x = org.x &lt; 0 ? -org.x : 0; y = org.y &lt; 0 ? -org.y : 0; LOGFONTA lf; lf.lfHeight = -fontSize; lf.lfWidth = 0; lf.lfEscapement = 0; lf.lfOrientation = 0; lf.lfWeight = 5; lf.lfItalic = italic; // 斜体 lf.lfUnderline = underline; // 下划线 lf.lfStrikeOut = 0; lf.lfCharSet = DEFAULT_CHARSET; lf.lfOutPrecision = 0; lf.lfClipPrecision = 0; lf.lfQuality = PROOF_QUALITY; lf.lfPitchAndFamily = 0; strcpy_s(lf.lfFaceName, fn); HFONT hf = CreateFontIndirectA(&amp;lf); HDC hDC = CreateCompatibleDC(0); HFONT hOldFont = (HFONT)SelectObject(hDC, hf); int strBaseW = 0, strBaseH = 0; int singleRow = 0; char buf[1 &lt;&lt; 12]; strcpy_s(buf, str); char* bufT[1 &lt;&lt; 12]; // 这个用于分隔字符串后剩余的字符，可能会超出。 // 处理多行 { int nnh = 0; int cw, ch; const char* ln = strtok_s(buf, &quot;\\n&quot;, bufT); while (ln != 0) { GetStringSize(hDC, ln, &amp;cw, &amp;ch); strBaseW = std::max(strBaseW, cw); strBaseH = std::max(strBaseH, ch); ln = strtok_s(0, &quot;\\n&quot;, bufT); nnh++; } singleRow = strBaseH; strBaseH *= nnh; } if (org.x + strBaseW &lt; 0 || org.y + strBaseH &lt; 0) { SelectObject(hDC, hOldFont); DeleteObject(hf); DeleteObject(hDC); return; } r = org.x + strBaseW &gt; dst.cols ? dst.cols - org.x - 1 : strBaseW - 1; b = org.y + strBaseH &gt; dst.rows ? dst.rows - org.y - 1 : strBaseH - 1; org.x = org.x &lt; 0 ? 0 : org.x; org.y = org.y &lt; 0 ? 0 : org.y; BITMAPINFO bmp = { 0 }; BITMAPINFOHEADER&amp; bih = bmp.bmiHeader; int strDrawLineStep = strBaseW * 3 % 4 == 0 ? strBaseW * 3 : (strBaseW * 3 + 4 - ((strBaseW * 3) % 4)); bih.biSize = sizeof(BITMAPINFOHEADER); bih.biWidth = strBaseW; bih.biHeight = strBaseH; bih.biPlanes = 1; bih.biBitCount = 24; bih.biCompression = BI_RGB; bih.biSizeImage = strBaseH * strDrawLineStep; bih.biClrUsed = 0; bih.biClrImportant = 0; void* pDibData = 0; HBITMAP hBmp = CreateDIBSection(hDC, &amp;bmp, DIB_RGB_COLORS, &amp;pDibData, 0, 0); CV_Assert(pDibData != 0); HBITMAP hOldBmp = (HBITMAP)SelectObject(hDC, hBmp); //color.val[2], color.val[1], color.val[0] SetTextColor(hDC, RGB(255, 255, 255)); SetBkColor(hDC, 0); //SetStretchBltMode(hDC, COLORONCOLOR); strcpy_s(buf, str); const char* ln = strtok_s(buf, &quot;\\n&quot;, bufT); int outTextY = 0; while (ln != 0) { TextOutA(hDC, 0, outTextY, ln, strlen(ln)); outTextY += singleRow; ln = strtok_s(0, &quot;\\n&quot;, bufT); } uchar* dstData = (uchar*)dst.data; int dstStep = dst.step / sizeof(dstData[0]); unsigned char* pImg = (unsigned char*)dst.data + org.x * dst.channels() + org.y * dstStep; unsigned char* pStr = (unsigned char*)pDibData + x * 3; for (int tty = y; tty &lt;= b; ++tty) { unsigned char* subImg = pImg + (tty - y) * dstStep; unsigned char* subStr = pStr + (strBaseH - tty - 1) * strDrawLineStep; for (int ttx = x; ttx &lt;= r; ++ttx) { for (int n = 0; n &lt; dst.channels(); ++n) { double vtxt = subStr[n] / 255.0; int cvv = vtxt * color.val[n] + (1 - vtxt) * subImg[n]; subImg[n] = cvv &gt; 255 ? 255 : (cvv &lt; 0 ? 0 : cvv); } subStr += 3; subImg += dst.channels(); } } SelectObject(hDC, hOldBmp); SelectObject(hDC, hOldFont); DeleteObject(hf); DeleteObject(hBmp); DeleteDC(hDC); }}#endif // CV_PUTTEXTZH_H main.cpp1234567891011121314151617#include &quot;cv_puttextzh.h&quot;int main() { cv::Mat image = cv::Mat(500, 500,CV_8UC3); cv::putTextZH( image, &quot; 你好！OpenCV&quot;, cv::Point(image.cols/3, image.rows / 2), CV_RGB(255, 255, 255), 30 ); cv::imshow(&quot; 中文图窗 &quot;, image); cv::waitKey(0); return 0;} CMakeLists.txt >folded12345678910111213141516171819202122# cmake needs this linecmake_minimum_required(VERSION 3.18)# Define project nameproject(OpenCVputTextZH)if (MSVC) # 设置 msvc 代码编码格式为 utf-8 set(CMAKE_C_FLAGS &quot;/source-charset:utf-8 ${CMAKE_C_FLAGS}&quot;) set(CMAKE_CXX_FLAGS &quot;/source-charset:utf-8 ${CMAKE_CXX_FLAGS}&quot;) message(STATUS &quot;CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}&quot;) message(STATUS &quot;CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}&quot;)endif()find_package(OpenCV 3 REQUIRED )include_directories(${OpenCV_INCLUDE_DIRS})# Declare the executable target built from your sourcesadd_executable(demo main.cpp)# Link your application with OpenCV librariestarget_link_libraries(demo PRIVATE ${OpenCV_LIBS}) 12345&gt; lsCMakeLists.txt main.cpp cv_puttextzh.h&gt; mkdir build&gt; cd build&gt; cmake .. -A x64 -DOpenCV_DIR=D:/OpenCV/opencv/build/x64/vc15/lib 如果是其他平台，在 OpenCV 显示中文 | 知乎 中也有解决方案，但需要结合 freetype 和 harfbuzz 重新编译 opencv_contrib. 常用颜色 BGR 值 cv_color_def.h >folded12345678910111213141516171819202122232425262728293031// OpenCV 常用颜色 BGR 值 #ifndef CV_COLOR_DEF_H#define CV_COLOR_DEF_H#include &lt;opencv2/core/types.hpp&gt;#define CV_COLOR_RED cv::Scalar(0,0,255) // 纯红 #define CV_COLOR_GREEN cv::Scalar(0,255,0) // 纯绿 #define CV_COLOR_BLUE cv::Scalar(255,0,0) // 纯蓝 #define CV_COLOR_DARKGRAY cv::Scalar(169,169,169) // 深灰色 #define CV_COLOR_DARKRED cv::Scalar(0,0,139) // 深红色 #define CV_COLOR_ORANGERED cv::Scalar(0,69,255) // 橙红色 #define CV_COLOR_CHOCOLATE cv::Scalar(30,105,210) // 巧克力 #define CV_COLOR_GOLD cv::Scalar(10,215,255) // 金色 #define CV_COLOR_YELLOW cv::Scalar(0,255,255) // 纯黄色 #define CV_COLOR_OLIVE cv::Scalar(0,128,128) // 橄榄色 #define CV_COLOR_LIGHTGREEN cv::Scalar(144,238,144) // 浅绿色 #define CV_COLOR_DARKCYAN cv::Scalar(139,139,0) // 深青色 #define CV_COLOR_SKYBLUE cv::Scalar(230,216,173) // 天蓝色 #define CV_COLOR_INDIGO cv::Scalar(130,0,75) // 藏青色 #define CV_COLOR_PURPLE cv::Scalar(128,0,128) // 紫色 #define CV_COLOR_PINK cv::Scalar(203,192,255) // 粉色 #define CV_COLOR_DEEPPINK cv::Scalar(147,20,255) // 深粉色 #define CV_COLOR_VIOLET cv::Scalar(238,130,238) // 紫罗兰 #endif // CV_COLOR_DEF_H","link":"/blogs/cv_puttextzh/"}],"tags":[{"name":"resume","slug":"resume","link":"/tags/resume/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"WinSCP","slug":"WinSCP","link":"/tags/WinSCP/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"文件传输","slug":"文件传输","link":"/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"build","slug":"build","link":"/tags/build/"},{"name":"vtk","slug":"vtk","link":"/tags/vtk/"},{"name":"vs","slug":"vs","link":"/tags/vs/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"opencv","slug":"opencv","link":"/tags/opencv/"},{"name":"license","slug":"license","link":"/tags/license/"},{"name":"msvc","slug":"msvc","link":"/tags/msvc/"}],"categories":[{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"tips","slug":"tips","link":"/categories/tips/"}],"pages":[]}